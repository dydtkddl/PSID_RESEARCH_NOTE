
---

title: "ChemicBook | Extended-Connectivity Fingerprints(ECFPs) 초보자 가이드" date: "2021-03-25" tags: [] source: "chemicbook.com (Manish Kumar)"

Extended-Connectivity Fingerprints(ECFPs)는 분자의 활성과 관련된 특징을 포착하도록 명시적으로 설계된 분자 지문(molecular fingerprint)의 한 종류이다. ECFP는 신약개발에서 유사도 검색(similarity search)에 가장 널리 쓰이는 도구 중 하나이며, 다양한 응용 분야에서 효과적으로 활용된다.

ECFP 특징을 생성하는 과정은 크게 네 단계로 설명할 수 있다. 먼저 벤즈아마이드(Benzamide)를 예로 들면, 특정 원자(예: 6번 원자)를 중심으로 특징을 만들 때도 동일한 흐름이 적용된다. 첫 단계에서는 분자 내 각 원자에 고유한 정수 식별자(integer identifier)를 부여한다. 이 식별자는 원자번호, 원자량 등과 같은 원자/결합 속성들의 조합을 해시(hashing)하여 만든 값이며, 초기 식별자는 “해당 원자 자체와 그에 직접 연결된 결합”에 대한 정보만을 담는다. 두 번째 단계에서는 각 원자가 자기 식별자와 인접한 이웃 원자들의 식별자를 모아 배열로 만든 뒤, 이를 다시 해시하여 새로운 단일 정수 식별자로 압축한다. 이렇게 하면 원자 주변 환경(이웃 원자의 종류와 결합)이 반영되며, 이 갱신(update)은 사용자가 정한 횟수만큼 반복된다. 초기 반복에서는 원자 자체의 특성이 중심이고, 다음 반복에서는 이웃, 그다음에는 이웃의 이웃까지 점차 넓은 반경의 정보가 포함된다. 세 번째 단계는 중복 제거(de-duplication)로, 반복이 늘어나면 서로 다른 중심 원자에서 동일한(또는 구조적으로 중복되는) 부분구조(substructure)가 생성될 수 있으므로 이를 제거한다. 네 번째 단계에서는 최종적으로 얻은 식별자들을 지정한 길이의 비트 배열(bit array)로 사상하여, 컴퓨터가 다루기 쉬운 고정 길이의 지문 형태로 만든다. 이 전체 과정은 특정 원자 하나에만 수행되는 것이 아니라 분자 내 모든 원자를 중심으로 반복되며, 결과적으로 각 원자가 분자 전반의 부분구조 정보를 포함하는 식별자들을 생성하게 된다.

이제 각 단계를 조금 더 구체적으로 살펴보기 위해 부티라마이드(Butyramide) 분자를 예로 들자. 첫 단계인 “원자별 정수 식별자 부여”에서는 Daylight atomic invariants 규칙을 사용한다. 이 규칙은 원자에 붙인 인덱스 번호(예: 6번 원자를 1번으로 바꾸어도)와 무관하게 동일한 원자 환경이면 같은 불변량(invariant)이 나오도록 설계된 원자 속성 집합이다. 구체적으로는 비수소(non-hydrogen) 즉시 이웃 원자 수, 수소 결합을 무시한 총 결합차수(정확히는 ‘원자가수(valency) − 연결된 수소 수’로 설명), 원자번호, 원자질량, 원자 전하, 부착된 수소 수(implicit/explicit 포함)의 여섯 가지가 핵심이며, 실무에서는 추가로 해당 원자가 고리(ring)에 속하는지 여부(속하면 1, 아니면 0)를 더해 일곱 번째 속성으로 쓰는 경우가 많다. 이렇게 얻은 원자 속성 튜플을 해시 함수로 정수로 바꾸면, 그 값이 초기 식별자가 된다. 예를 들어 부티라마이드의 4번 원자에 대해 비수소 이웃 원자 수는 3(3, 5, 6번), ‘원자가수 − 수소 수’는 4(4 − 0), 원자번호는 6, 원자질량은 12, 전하는 0, 부착 수소는 0, 고리 포함 여부는 0이므로 f4 = (3, 4, 6, 12, 0, 0, 0)처럼 정리할 수 있다. 파이썬에서는 이 튜플을 그대로 hash()에 넣어 정수 식별자를 만들 수 있으며(언어마다 해시가 달라질 수 있음), 이 과정을 모든 원자에 대해 반복해 초기 특징 집합을 만든다.

두 번째 단계인 “원자 식별자의 반복적 갱신”에서는 각 원자가 자신의 현재 식별자와 이웃 원자들의 현재 식별자, 그리고 결합 정보를 함께 묶어 다시 해시한다. 절차는 다음과 같은 직관으로 이해하면 된다. 먼저 “반복 횟수(iteration index)”와 “중심 원자 식별자”를 포함하는 배열을 시작점으로 만든다. 그다음 비수소 이웃 원자마다 두 값을 추가하는데, 하나는 해당 이웃과의 결합차수(단일/이중/삼중/방향족을 각각 1/2/3/4로 부호화), 다른 하나는 그 이웃 원자의 현재 식별자이다. 이때 이웃 목록의 순서에 따라 결과가 달라지지 않도록 (결합차수, 이웃식별자) 쌍을 정렬한 뒤 결합한다. 예를 들어 4번 원자가 5번, 3번과 단일결합이고 6번과 이중결합이라면, 중심(4번) 관점의 특징 배열은 반복 번호와 중심 식별자를 포함한 뒤 (1, 이웃5의 식별자), (1, 이웃3의 식별자), (2, 이웃6의 식별자)를 붙인 형태가 되며, 이를 다시 하나의 리스트로 평탄화한 뒤 튜플로 바꿔 해시하면 갱신된 식별자가 된다. 이 갱신은 모든 원자에 대해 동일하게 수행되며, 지정한 반복 횟수만큼 계속된다. 또한 각 반복에서 얻은 식별자들은 누적(feature list에 추가)되므로, 초기 단계에서 원자 수만큼 식별자가 생기고, 1회 반복 후에도 원자 수만큼이 추가되며, 2회 반복 후에도 다시 원자 수만큼이 추가되는 식으로 특징 후보가 늘어난다.

흥미로운 점은, 어떤 두 원자가 초기 단계에서는 동일한 식별자를 가질 수 있지만 한 번만 주변을 포함해 갱신하면 서로 달라질 수 있다는 것이다. 이는 원자 자체만 보면 동일한 유형이더라도 주변 환경이 다르기 때문이다. 예컨대 한 원자는 -CH3에 연결되어 있고 다른 원자는 -C(=O)NH2에 연결되어 있다면, 초기에는 같은 불변량을 가질 수 있어도 이웃을 반영하는 순간 식별자가 달라진다. 요약하면, ECFP의 반복 갱신은 “같은 원자라도 어떤 환경에 놓였는지”를 점진적으로 반영하는 메커니즘이다.

세 번째 단계는 “중복 구조 제거”이다. 반복 횟수가 늘어나면 여러 중심 원자에서 동일하거나 구조적으로 중복되는 부분구조가 생성될 수 있다. 단순히 식별자 값이 같아서 중복인 경우는 하나를 제거하면 된다. 하지만 식별자 값이 다르더라도 실제로는 같은 부분구조를 가리키는 중복이 생길 수 있는데, 예를 들어 2회 반복에서 산소(O)를 중심으로 만들었을 때와 질소(N)를 중심으로 만들었을 때 동일한 부분구조가 포함될 수 있다. 이때는 단순히 정수 값 비교만으로는 중복을 판별할 수 없으므로, 각 식별자가 “그 식별자가 대표하는 결합(bond)들의 집합”을 추적하도록 한다. 매 반복에서 결합 집합은 (이전 반복에서의 중심 원자 결합 집합), (이전 반복에서의 이웃 원자 결합 집합들), 그리고 (현재 반복에서 추가된 부착 결합들)을 합집합으로 갱신한다. 이렇게 얻은 결합 목록은 해당 특징이 덮는 부분구조를 정의하며, 새로 생성된 특징을 지문 집합에 추가하기 전에 기존 특징(또는 같은 반복에서 새로 만들어진 특징)과 구조 중복 여부를 검사해 중복을 제거한다. 그 결과 최종적으로는 “서로 다른 부분구조를 대표하는 식별자들의 집합”만 남게 된다.

네 번째 단계는 “식별자를 비트 배열로 변환”하는 과정이다. 사용자는 먼저 지문 길이(예: 1024)를 정하고, 그 길이의 0 배열을 만든다. 이후 각 식별자에 대해 배열 길이로 나눈 나머지(remainder)를 계산한다. 파이썬에서는 % 연산으로 구현하며, 예를 들어 어떤 식별자 값이 -4080868480043360372라면 -4080868480043360372 % 1024 = 908처럼 인덱스가 결정된다. 이렇게 모든 식별자에 대한 나머지 인덱스를 구한 뒤, 해당 인덱스 위치의 값을 1로 설정하면 최종적인 비트 지문이 된다. 결과적으로 1024개 비트 중 일부(일반적으로 3~30개 정도)만 1이 되고 나머지는 0인 희소(sparse)한 벡터가 만들어진다.

이 과정을 직관적으로 다시 보면, 각 식별자는 결국 분자 내부의 “부분구조 서명(signature)”에 해당한다고 이해할 수 있다. 예를 들어 산소를 중심으로 보면, 초기에는 단지 이중결합 산소의 정보만 담기지만, 1회 반복 후에는 카보닐(carbonyl) 정보가 포함되고, 2회 반복 후에는 지방족 카복사마이드(aliphatic carboxylic acid amide)처럼 더 큰 부분구조가 표현될 수 있다. 즉 반복 횟수가 조금만 늘어도 더 넓은 화학적 문맥이 특징에 빠르게 포함된다.

또한 ECFP4, ECFP6처럼 뒤에 붙는 숫자는 “가장 큰 특징의 유효 지름(effective diameter)”을 의미하며, 이는 반복 횟수의 두 배에 해당한다. 예를 들어 2회 반복을 수행하면 가장 큰 조각(fragment)의 폭이 4 결합(bonds)까지 확장될 수 있으므로 ECFP4라고 부른다. 이런 의미에서 ECFP4는 “지름 4의 ECFP”라는 관례적 표기이며, 문헌에서는 ECFP_4처럼 밑줄 표기를 쓰는 경우도 있다.

초기 불변량으로 Daylight 규칙만 써야 하는 것은 아니다. 초기 튜플에 사용자가 원하는 다른 원자 특성을 추가하여 변형된 ECFP를 만들 수도 있다. 예를 들어 Sybyl 원자 타입을 사용한 변형은 SCFP로, aLogP 원자 코드를 사용한 변형은 LCFP로 불리기도 한다.

비트 충돌(bit collision)은 “서로 다른 식별자들이 같은 비트 위치로 접히는(fold) 현상”을 말한다. 비트 배열 길이가 1024일 때, 어떤 식별자 A와 식별자 B가 서로 다른 정수여도 둘 다 % 1024의 결과가 908이라면 두 특징은 동일한 908번째 비트를 1로 만들며, 그 과정에서 구분 정보 일부가 사라진다. 배열 길이를 2048로 늘리면 두 값의 나머지가 달라져 충돌이 줄어들 수 있지만, 길이를 늘릴수록 벡터가 더 희소해지고 0이 많아지는 trade-off가 생긴다. 충돌은 가능하지만 빈번하지 않은 경우가 많아서, 실무에서는 1024 길이가 대체로 충분하다고 본다.

마지막으로, ECFP를 사용할 때 자주 강조되는 실무 포인트는 다음과 같다. 일반적으로 수소 원자와 수소에 대한 결합은 무시되며, 식별자 값은 해시 함수에 의존하므로 언어나 해시 구현이 다르면 동일한 분자라도 식별자 정수 값이 달라질 수 있어(의미 자체는 같더라도) 일관된 구현을 쓰는 것이 중요하다. 반복 횟수는 목적에 따라 달라지는데, 유사도 검색이나 클러스터링 목적이라면 보통 2회 반복(즉 ECFP4)이 충분한 경우가 많고, 활성 예측(activity learning)처럼 더 정교한 구조 정보를 쓰고 싶을 때는 3~4회 이상의 반복이 도움이 될 수 있다.

참고 문헌으로는 Rogers, D., & Hahn, M. (2010). “Extended-Connectivity Fingerprints.” Journal of Chemical Information and Modeling, 50(5), 742–754. doi:10.1021/ci100050t 가 널리 인용되며, Chemaxon 문서의 ECFP 설명 페이지도 함께 참고할 수 있다.
