{% extends "base.html" %}

{% block extra_head %}
  {% if media_base_url %}
    <base href="{{ media_base_url }}/">
  {% endif %}

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.2.0/github-markdown-light.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Pretendard:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>

  <script>
    window.MathJax = {
      loader: { load: ['input/tex', 'output/svg'] },
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true
      },
      svg: {
        fontCache: 'none',
        scale: 1,
        displayAlign: 'center',
        displayIndent: '0'
      },
      startup: {
        ready: () => {
          console.log("[MathJax] Startup ready.");
          MathJax.startup.defaultReady();
          window.mathJaxReady = true;
        }
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

  <style>
    /* ==========================================
       3. CSS Styling
       ========================================== */
    :root {
      --paper-bg: #ffffff;
      --app-bg: #f5f7fa; 
      --primary-color: #2da44e;
      --border-color: #d0d7de;
      --text-color: #24292f;
    }

    /* --- Layout --- */
    .viewer-layout {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      gap: 40px;
      padding-bottom: 60px;
    }

    .viewer-main {
      width: 100%;
      display: flex;
      justify-content: center;
      padding: 0 !important;
    }

    /* Paper Style Container */
    .page-container { 
      width: 100%;
      max-width: 900px; 
      margin: 0 auto; 
      padding: 60px 70px; 
      background: var(--paper-bg); 
      box-shadow: 0 4px 24px rgba(0,0,0,0.06);
      border-radius: 4px;
      box-sizing: border-box;
      min-height: calc(100vh - 120px);
      transition: font-size 0.2s ease;
    }

    /* --- Paper Header --- */
    .paper-header { margin-bottom: 40px; padding-bottom: 20px; border-bottom: 1px solid #eaecef; }
    .paper-title { font-family: 'Pretendard', sans-serif; font-size: 2.4em; font-weight: 700; margin-bottom: 15px; color: #1f2328; line-height: 1.3; word-break: keep-all; }
    .paper-meta-grid { display: flex; flex-wrap: wrap; gap: 15px; color: #57606a; margin-bottom: 20px; font-size: 0.95em; }
    .meta-item { display: flex; align-items: center; gap: 6px; }
    
    .tags-container { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 15px; }
    .tag-badge { background-color: #ddf4ff; color: #0969da; padding: 4px 10px; border-radius: 100px; font-size: 0.85em; font-weight: 600; white-space: nowrap; }
    
    .summary-box { background-color: #f6f8fa; border: 1px solid var(--border-color); border-radius: 6px; padding: 20px; margin-top: 25px; line-height: 1.6; font-size: 0.95rem; }
    .summary-title { font-weight: 600; margin-bottom: 8px; color: #1f2328; display: flex; align-items: center; gap: 6px; }

    /* --- Markdown Content --- */
    .markdown-body { 
      font-family: 'Pretendard', sans-serif !important; 
      line-height: 1.8 !important; 
      color: var(--text-color); 
      background-color: transparent !important; 
    }
    .markdown-body h1, .markdown-body h2 { border-bottom: none !important; margin-top: 1.5em; }
    .markdown-body table { display: block; width: 100%; overflow-x: auto; border-collapse: collapse; margin-bottom: 20px; }
    .markdown-body table th, .markdown-body table td { border: 1px solid var(--border-color) !important; padding: 8px 12px; }
    .markdown-body table th { background-color: #f6f8fa !important; font-weight: 600; }
    .markdown-body img { max-width: 100%; height: auto; border-radius: 4px; }
    
    /* MathJax Containers */
    mjx-container:not([display="true"]) { display: inline-block; vertical-align: middle; margin: 0 2px; }
    mjx-container[display="true"] { display: block; overflow-x: auto; max-width: 100%; margin: 1em 0; }

    /* --- Comment System (New & Threaded) --- */
    .comment-section {
      margin-top: 60px;
      padding-top: 40px;
      border-top: 1px solid #eaecef;
    }
    .comment-section-title {
      font-size: 1.3em; font-weight: 700; margin-bottom: 25px;
      display: flex; align-items: center; gap: 10px; color: #24292f;
    }
    
    .comment-list { display: flex; flex-direction: column; gap: 20px; margin-bottom: 40px; }
    
    /* Individual Thread */
    .comment-thread { display: flex; flex-direction: column; gap: 10px; }
    
    /* Parent Comment */
    .comment-item {
      background: #f8f9fa;
      border: 1px solid #d0d7de;
      border-radius: 8px;
      padding: 16px;
      position: relative;
      transition: all 0.2s ease;
    }
    .comment-item:hover { box-shadow: 0 4px 12px rgba(0,0,0,0.05); }
    
    /* Child Comment (Reply) - Indented */
    .comment-reply-item {
      margin-left: 40px; 
      background: #ffffff;
      border: 1px solid #eaecef;
      border-left: 4px solid var(--primary-color);
      border-radius: 0 8px 8px 0;
      padding: 12px 16px;
    }

    .comment-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px; }
    .comment-meta { font-size: 0.85em; color: #57606a; display: flex; align-items: center; gap: 8px; }
    .comment-date { font-family: 'JetBrains Mono', monospace; }
    .comment-body { font-size: 0.95em; line-height: 1.6; color: #24292f; white-space: pre-wrap; word-break: break-word; }
    
    .comment-actions { display: flex; gap: 12px; font-size: 0.85em; margin-top: 12px; opacity: 0.8; }
    .comment-item:hover .comment-actions { opacity: 1; }
    .act-btn { cursor: pointer; color: #57606a; font-weight: 500; display: inline-flex; align-items: center; gap: 4px; transition: color 0.2s; }
    .act-btn:hover { color: #0969da; text-decoration: underline; }
    .act-btn.delete:hover { color: #cf222e; }

    /* Forms */
    .comment-form-container { margin-top: 20px; }
    .comment-input-wrapper { position: relative; }
    .comment-input {
      width: 100%; min-height: 100px; padding: 15px;
      border: 1px solid #d0d7de; border-radius: 8px;
      font-family: 'Pretendard', sans-serif; font-size: 0.95em; resize: vertical;
      background: #f6f8fa; transition: all 0.2s;
      box-sizing: border-box;
    }
    .comment-input:focus { outline: none; border-color: var(--primary-color); background: #fff; box-shadow: 0 0 0 3px rgba(45, 164, 78, 0.1); }
    .btn-submit {
      margin-top: 10px; float: right;
      background: var(--primary-color); color: white; border: none;
      padding: 8px 24px; border-radius: 6px; font-weight: 600; cursor: pointer;
      transition: background 0.2s;
    }
    .btn-submit:hover { background: #2c974b; }
    .clearfix::after { content: ""; clear: both; display: table; }

    /* Hidden Reply Form */
    .reply-form-container { display: none; margin-left: 40px; margin-top: 10px; padding: 10px; background: #f6f8fa; border-radius: 8px; border: 1px solid #eee; }
    .reply-form-container.active { display: block; animation: fadeIn 0.3s ease; }
    
    @keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }

    /* --- Sidebar (Bottom Panel) --- */
    .viewer-sidebar { width: 100%; max-width: 900px; margin-top: 0; padding-top: 40px; border-top: 1px solid #eaecef; }
    .viewer-sidebar h3 { font-size: 1.1em; margin-bottom: 15px; color: #444; border-left: 4px solid var(--primary-color); padding-left: 12px; }
    .sidebar-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 30px; }
    .other-notes, .attachments-list { list-style: none; padding: 0; margin: 0; }
    .other-notes li, .attachments-list li {
      margin-bottom: 8px; padding: 10px 14px;
      background: #fff; border: 1px solid #eee; border-radius: 6px; font-size: 0.9em;
      transition: all 0.2s;
    }
    .other-notes li:hover, .attachments-list li:hover { background: #f8f9fa; border-color: #ddd; transform: translateY(-1px); box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
    .other-notes a { text-decoration: none; color: #0969da; font-weight: 500; display: block; }

    /* --- Top Controls --- */
    .control-group { display: flex; align-items: center; gap: 10px; background: #fff; padding: 6px 14px; border-radius: 20px; border: 1px solid #d0d7de; margin-right: 12px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
    .font-size-slider { width: 80px; accent-color: var(--primary-color); cursor: pointer; }
    .font-label { font-size: 0.85em; color: #555; white-space: nowrap; font-weight: 600; min-width: 36px; text-align: center; }

    /* --- Highlight UI --- */
    .hl-toolbar{ position: fixed; z-index: 9999; background: #fff; border: 1px solid #ddd; border-radius: 12px; padding: 12px; box-shadow: 0 8px 24px rgba(0,0,0,0.15); max-width: 360px; width: 320px; }
    .hl-colors{ display:flex; gap:10px; align-items:center; margin-bottom:12px; flex-wrap:wrap; }
    .hl-color{ width: 24px; height: 24px; border-radius: 6px; border: 1px solid #ccc; cursor: pointer; transition: transform 0.1s; }
    .hl-color:hover { transform: scale(1.1); }
    /* Palette */
    .hl-color[data-color="#fff59d"]{ background:#fff59d; } .hl-color[data-color="#c8e6c9"]{ background:#c8e6c9; }
    .hl-color[data-color="#bbdefb"]{ background:#bbdefb; } .hl-color[data-color="#ffcdd2"]{ background:#ffcdd2; }
    .hl-color[data-color="#ffe0b2"]{ background:#ffe0b2; } .hl-color[data-color="#d1c4e9"]{ background:#d1c4e9; }
    .hl-color[data-color="#b2dfdb"]{ background:#b2dfdb; } .hl-color[data-color="#f8bbd0"]{ background:#f8bbd0; }
    #hl-custom{ width: 40px; height: 26px; padding:0; border:none; background:transparent; cursor:pointer; }
    .hl-note{ width:100%; box-sizing:border-box; padding:10px; border:1px solid #ddd; border-radius:8px; margin-bottom:10px; font-family: inherit; }
    .hl-actions{ display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; }
    .hl-span{ border-radius: 4px; padding: 2px 0; cursor: pointer; box-decoration-break: clone; -webkit-box-decoration-break: clone; }
    .hl-span[data-hl-end="1"][data-hl-note]:not([data-hl-note=""])::after{ content: "ğŸ“"; font-size: 0.9em; margin-left: 2px; vertical-align: top; opacity: 0.7; }
    
    .hl-fab{ position: fixed; right: 24px; bottom: 24px; z-index: 10001; border: 1px solid rgba(0,0,0,.1); border-radius: 50px; padding: 12px 20px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); background: #fff; cursor: pointer; display: inline-flex; align-items: center; gap: 8px; font-weight: 700; transition: transform 0.2s; }
    .hl-fab:hover { transform: translateY(-2px); }
    .hl-fab .dot{ width: 10px; height: 10px; border-radius: 50%; background: var(--primary-color); }
    .hl-fab[data-on="0"] .dot{ background: #9e9e9e; }

    /* --- PDF Modal --- */
    .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000; display: none; justify-content: center; align-items: center; backdrop-filter: blur(2px); }
    .modal-content { background: white; padding: 30px; border-radius: 16px; width: 90%; max-width: 420px; box-shadow: 0 20px 40px rgba(0,0,0,0.2); }
    .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px; font-weight: 700; font-size: 1.25rem; }
    .close-modal { cursor: pointer; color: #888; transition: color 0.2s; } .close-modal:hover { color: #333; }
    .setting-group { margin-bottom: 20px; }
    .setting-label { display: block; font-weight: 600; margin-bottom: 8px; font-size: 0.9rem; color: #444; }
    select, input[type=range] { width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #ddd; }
    .btn-row { display: flex; gap: 10px; margin-top: 30px; }
    .btn-cancel, .btn-confirm { flex: 1; padding: 12px; border-radius: 8px; cursor: pointer; font-weight: 600; border: none; font-size: 1rem; }
    .btn-cancel { background: white; border: 1px solid #ddd; color: #555; }
    .btn-confirm { background: var(--primary-color); color: white; flex: 2; }
    .progress-wrapper { display: none; margin-top: 20px; text-align: center; }
    .progress-container { width: 100%; background: #f3f3f3; border-radius: 10px; height: 8px; overflow: hidden; margin-bottom: 8px; }
    .progress-bar { width: 0%; height: 100%; background: var(--primary-color); transition: width 0.3s ease; }
    .progress-text { font-size: 0.9em; color: #666; font-weight: 600; }

    /* Mobile Responsive */
    @media (max-width: 768px) {
      .page-container { padding: 40px 20px; border-radius: 0; min-height: 100vh; box-shadow: none; }
      .hl-toolbar{ width: 90%; left: 5% !important; }
      .control-group { display: none; } /* Mobile: Hide font slider */
      .comment-reply-item { margin-left: 20px; }
    }
  </style>
{% endblock %}

{% block content %}

<div class="detail-header" style="margin-bottom: 0; padding: 15px 20px; background: #fff; border-bottom: 1px solid #eee;">
  <div class="detail-nav-left">
    {% if project_rel_path %}
      <a class="btn-secondary" href="{{ url_for('project_view') }}?rel_path={{ project_rel_path }}">
        <i class="fas fa-arrow-left"></i> ëª©ë¡ìœ¼ë¡œ
      </a>
    {% else %}
      <button type="button" class="btn-secondary" onclick="window.history.back()">
        <i class="fas fa-arrow-left"></i> ë’¤ë¡œê°€ê¸°
      </button>
    {% endif %}
  </div>

  <div class="detail-nav-right" style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
    
    {% if html_content %}
    <div class="control-group" title="ê¸€ì í¬ê¸° ì¡°ì ˆ">
      <i class="fas fa-font" style="font-size:0.9em; color:#666;"></i>
      <input type="range" class="font-size-slider" id="globalFontSize" min="12" max="24" step="1" value="16">
      <span class="font-label" id="globalFontVal">16px</span>
    </div>
    {% endif %}

    <button type="button" class="btn-secondary" onclick="openPdfSettings()">
      <i class="fas fa-file-pdf"></i> PDF
    </button>

    {% if is_markdown %}
      <a class="btn-secondary" href="{{ url_for('edit_file') }}?rel_path={{ rel_path }}">
        <i class="fas fa-edit"></i> í¸ì§‘
      </a>
    {% endif %}
    
    <form method="post" action="{{ url_for('toggle_favorite') }}" style="display:inline;">
      <input type="hidden" name="rel_path" value="{{ rel_path }}">
      <button type="submit" class="btn-secondary">
        {% if is_favorite %}<i class="fas fa-star" style="color:gold;"></i>{% else %}<i class="far fa-star"></i>{% endif %}
      </button>
    </form>
  </div>
</div>

<div class="modal-overlay" id="pdfModal">
  <div class="modal-content">
    <div class="modal-header">
      <span id="modalTitle">PDF ë‚´ë³´ë‚´ê¸° ì„¤ì •</span>
      <i class="fas fa-times close-modal" onclick="closePdfSettings()" id="modalCloseBtn"></i>
    </div>
    
    <div id="pdfSettingsArea">
      <div class="setting-group">
        <label class="setting-label">ê¸€ì í¬ê¸°: <span id="pdfFontSizeVal">16px</span></label>
        <input type="range" id="pdfFontSizeRange" min="12" max="24" step="1" value="16" oninput="previewPdfFontSize(this.value)">
      </div>

      <div class="setting-group">
        <label class="setting-label">ìš©ì§€ ë°©í–¥</label>
        <select id="pdfOrientation">
          <option value="portrait">ì„¸ë¡œ (Portrait)</option>
          <option value="landscape">ê°€ë¡œ (Landscape)</option>
        </select>
      </div>

      <div class="setting-group">
        <label class="setting-label">ì—¬ë°± ì„¤ì •</label>
        <select id="pdfMargin">
          <option value="narrow">ì¢ê²Œ (5mm)</option>
          <option value="normal" selected>ë³´í†µ (15mm)</option>
          <option value="wide">ë„“ê²Œ (25mm)</option>
        </select>
      </div>

      <div class="btn-row">
        <button class="btn-cancel" onclick="closePdfSettings()">ì·¨ì†Œ</button>
        <button class="btn-confirm" onclick="startPdfGeneration()" id="confirmBtn">
          <i class="fas fa-download"></i> PDF ë‹¤ìš´ë¡œë“œ
        </button>
      </div>
    </div>

    <div class="progress-wrapper" id="progressArea">
      <div class="progress-container"><div class="progress-bar" id="realProgressBar"></div></div>
      <div class="progress-text" id="progressStatus">ì¤€ë¹„ ì¤‘...</div>
      <p style="font-size:0.8em; color:#999; margin-top:8px;">ìˆ˜ì‹ì´ ë§ì„ ê²½ìš° ì‹œê°„ì´ ì†Œìš”ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
    </div>
  </div>
</div>

<div class="viewer-layout">
  <section class="viewer-main">
    
    {% if is_pdf %}
      <embed src="{{ download_file_url }}" type="application/pdf" width="100%" height="800px" />

    {% elif html_content %}
      <div class="page-container" id="capture">
        
        <header class="paper-header">
          <h1 class="paper-title">{{ meta.paper_title or meta.title or meta.short_title or file_name }}</h1>
          
          <div class="paper-meta-grid">
            {% if meta.authors %} <div class="meta-item"><i class="fas fa-user-friends"></i> <span>{{ meta.authors }}</span></div> {% endif %}
            {% if meta.journal %} <div class="meta-item"><i class="fas fa-book"></i> <span>{{ meta.journal }}</span></div> {% endif %}
            {% if meta.date or meta.year %} <div class="meta-item"><i class="far fa-calendar-alt"></i> <span>{{ meta.date or meta.year }}</span></div> {% endif %}
          </div>

          {% if tags or meta.tags %}
            <div class="tags-container">
              {% for tag in (tags or meta.tags) %} <span class="tag-badge">#{{ tag }}</span> {% endfor %}
            </div>
          {% endif %}

          {% if meta.summary %}
            <div class="summary-box">
              <div class="summary-title"><i class="fas fa-lightbulb" style="color:#eac54f"></i> í•µì‹¬ ìš”ì•½</div>
              {{ meta.summary }}
            </div>
          {% endif %}

          {% if meta %}
            <details class="meta-details" style="margin-top: 15px; font-size: 0.85em; color: #777;">
              <summary>ì „ì²´ ë©”íƒ€ë°ì´í„°</summary>
              <table class="meta-table" style="margin-top:10px;">
                <tbody>{% for k, v in meta.items() %}<tr><th>{{ k }}</th><td>{{ v }}</td></tr>{% endfor %}</tbody>
              </table>
            </details>
          {% endif %}
        </header>

        <article class="markdown-body" id="md-container">
          {{ html_content | safe }}
        </article>

        <div style="height: 40px;"></div>

        <div class="comment-section">
          <div class="comment-section-title">
            <i class="far fa-comments"></i> ëŒ“ê¸€ ë° ë…¸íŠ¸
          </div>
          
          <div id="comment-list" class="comment-list">
            </div>

          <div class="comment-form-container clearfix">
            <div class="comment-input-wrapper">
              <textarea id="comment-input" class="comment-input" placeholder="ì´ ë¬¸ì„œì— ëŒ€í•œ ìƒˆë¡œìš´ ë…¸íŠ¸ë‚˜ ì§ˆë¬¸ì„ ì‘ì„±í•˜ì„¸ìš”..."></textarea>
            </div>
            <button class="btn-submit" onclick="addComment(null)">ë“±ë¡</button>
          </div>
        </div>

        <div style="height: 50px;"></div>
        <div style="text-align: center; color: #ccc; font-size: 0.8em; margin-top: 30px; border-top: 1px solid #eee; padding-top: 20px;">
          Generated by Research Agent
        </div>
      </div>
    {% else %}
      <div class="page-container" style="text-align:center; padding: 100px;">
        <i class="fas fa-file-excel" style="font-size: 48px; color: #ddd; margin-bottom: 20px;"></i>
        <p>{{ unsupported_reason or "ì´ íŒŒì¼ì€ ë¯¸ë¦¬ë³´ê¸°ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤." }}</p>
        <a href="{{ download_file_url }}" class="btn">íŒŒì¼ ë‹¤ìš´ë¡œë“œ</a>
      </div>
    {% endif %}
  </section>

  {% if attachments or other_notes or recent_notes_panel or history_versions %}
    <aside class="viewer-sidebar">
      <div class="sidebar-grid">
        
        {% if recent_notes_panel %}
        <div>
          <h3>ìµœê·¼ ì—´ì–´ë³¸ ë…¸íŠ¸</h3>
          <ul class="other-notes">
            {% for n in recent_notes_panel %}
              <li><a href="{{ url_for('view_file') }}?rel_path={{ n.rel_path }}">{{ n.name }}</a></li>
            {% endfor %}
          </ul>
        </div>
        {% endif %}

        {% if other_notes %}
        <div>
          <h3>ê°™ì€ í”„ë¡œì íŠ¸ì˜ ë‹¤ë¥¸ ë…¸íŠ¸</h3>
          <ul class="other-notes">
            {% for note in other_notes %}
              <li><a href="{{ url_for('view_file') }}?rel_path={{ note.rel_path }}">{{ note.name }}</a></li>
            {% endfor %}
          </ul>
        </div>
        {% endif %}

        {% if history_versions or attachments %}
        <div>
          {% if history_versions %}
            <h3>ì´ì „ ìˆ˜ì • íˆìŠ¤í† ë¦¬</h3>
            <ul class="other-notes">
              {% for h in history_versions %}
                <li style="margin-bottom: 6px; display:flex; justify-content:space-between; align-items:center;">
                  <span style="font-size:0.85em; color:#666;">{{ h.saved_at }}</span>
                  <div style="display:flex; gap:8px; font-size:0.9em;">
                    <a href="{{ url_for('view_file') }}?rel_path={{ h.rel_path }}">ë³´ê¸°</a>
                    <a href="{{ url_for('download_file', rel_path=h.rel_path) }}">ë‹¤ìš´ë¡œë“œ</a>
                  </div>
                </li>
              {% endfor %}
            </ul>
          {% endif %}

          {% if attachments %}
            <h3 style="margin-top: 30px;">ì²¨ë¶€ íŒŒì¼</h3>
            <ul class="attachments-list">
              {% for att in attachments %}
                <li><a href="{{ url_for('download_file', rel_path=att.rel_path) }}">{{ att.name }}</a></li>
              {% endfor %}
            </ul>
          {% endif %}
        </div>
        {% endif %}

      </div>
    </aside>
  {% endif %}
</div>

{% if html_content %}
  <button id="hl-fab" class="hl-fab" type="button" aria-pressed="true" data-on="1" title="í˜•ê´‘íœ ëª¨ë“œ ON/OFF">
    <span class="dot" aria-hidden="true"></span>
    <span class="label">í˜•ê´‘íœ</span>
  </button>

  <div id="hl-toolbar" class="hl-toolbar" style="display:none;">
    <div class="hl-colors">
      <button type="button" class="hl-color" data-color="#fff59d" title="Yellow"></button>
      <button type="button" class="hl-color" data-color="#c8e6c9" title="Green"></button>
      <button type="button" class="hl-color" data-color="#bbdefb" title="Blue"></button>
      <button type="button" class="hl-color" data-color="#ffcdd2" title="Red"></button>
      <button type="button" class="hl-color" data-color="#ffe0b2" title="Orange"></button>
      <button type="button" class="hl-color" data-color="#d1c4e9" title="Purple"></button>
      <button type="button" class="hl-color" data-color="#b2dfdb" title="Teal"></button>
      <button type="button" class="hl-color" data-color="#f8bbd0" title="Pink"></button>
      <input type="color" id="hl-custom" title="Custom" />
    </div>
    <input id="hl-note" class="hl-note" placeholder="ë©”ëª¨ ì¶”ê°€..." />
    <div class="hl-actions">
      <button type="button" id="hl-edit" class="btn-secondary">âœï¸ í¸ì§‘ ì´ë™</button>
      <button type="button" id="hl-save" class="btn">ì €ì¥</button>
      <button type="button" id="hl-update" class="btn-secondary" style="display:none;">ìˆ˜ì •</button>
      <button type="button" id="hl-delete" class="btn-secondary" style="display:none;">ì‚­ì œ</button>
      <button type="button" id="hl-cancel" class="btn-secondary">ë‹«ê¸°</button>
    </div>
  </div>
{% endif %}

<script>
  // Global Variables
  const REL_PATH = {{ rel_path|tojson }};
  const NOTE_HASH = {{ content_hash|tojson }};
  const EDIT_URL = {{ (url_for('edit_file') ~ '') | tojson }};

  // --- [A] Comment System (Tree Structure) ---
  (function(){
    const listEl = document.getElementById('comment-list');
    const inputEl = document.getElementById('comment-input');
    
    if(!listEl) return;

    // 1. Fetch Comments
    async function loadComments(){
      try {
        const res = await fetch(`/research/comments?rel_path=${encodeURIComponent(REL_PATH)}`);
        if(!res.ok) throw new Error("Failed to load");
        const data = await res.json();
        renderThreadedComments(data.items || []);
      } catch(e) { 
        console.error(e); 
        listEl.innerHTML = '<div style="color:#d32f2f; text-align:center;">ëŒ“ê¸€ ë¡œë“œ ì‹¤íŒ¨</div>';
      }
    }

    // 2. Render Tree
    function renderThreadedComments(items){
      if(!items.length) {
        listEl.innerHTML = '<div style="color:#999; text-align:center; padding:30px; background:#fcfcfc; border:1px dashed #ddd; border-radius:8px;">ì•„ì§ ëŒ“ê¸€ì´ ì—†ìŠµë‹ˆë‹¤. ì²« ë²ˆì§¸ ë…¸íŠ¸ë¥¼ ë‚¨ê²¨ë³´ì„¸ìš”.</div>';
        return;
      }
      
      // Build Map: Parent -> Children
      const roots = items.filter(i => !i.parent_id);
      const childMap = {};
      items.forEach(i => {
        if(i.parent_id) {
          if(!childMap[i.parent_id]) childMap[i.parent_id] = [];
          childMap[i.parent_id].push(i);
        }
      });

      let html = "";
      roots.forEach(root => {
        // Parent
        html += buildCommentHTML(root, false);
        // Children (Replies)
        if(childMap[root.id]) {
          childMap[root.id].forEach(child => {
            html += buildCommentHTML(child, true);
          });
        }
      });
      listEl.innerHTML = html;
    }

    // 3. HTML Builder
    function buildCommentHTML(c, isReply) {
      const className = isReply ? "comment-item comment-reply-item" : "comment-item";
      const icon = isReply ? '<i class="fas fa-level-up-alt fa-rotate-90" style="margin-right:6px; color:#aaa;"></i>' : '';
      
      return `
        <div class="comment-thread">
          <div class="${className}" id="cmt-${c.id}">
            <div class="comment-header">
              <div class="comment-meta">
                ${icon}
                <span class="comment-date"><i class="far fa-clock"></i> ${c.created_at}</span>
                ${c.updated_at !== c.created_at ? '<span style="font-size:0.8em; color:#aaa;">(ìˆ˜ì •ë¨)</span>' : ''}
              </div>
              <div class="comment-actions">
                ${!isReply ? `<span class="act-btn" onclick="toggleReplyForm('${c.id}')"><i class="fas fa-reply"></i> ë‹µê¸€</span>` : ''}
                <span class="act-btn" onclick="editComment('${c.id}')">ìˆ˜ì •</span>
                <span class="act-btn delete" onclick="deleteComment('${c.id}')">ì‚­ì œ</span>
              </div>
            </div>
            <div class="comment-body" id="cmt-body-${c.id}">${escapeHtml(c.content)}</div>
          </div>
          
          <div id="reply-form-${c.id}" class="reply-form-container clearfix">
             <textarea id="reply-input-${c.id}" class="comment-input" style="min-height:60px;" placeholder="ë‹µê¸€ì„ ì…ë ¥í•˜ì„¸ìš”..."></textarea>
             <button class="btn-submit" onclick="addComment('${c.id}')">ë‹µê¸€ ë“±ë¡</button>
          </div>
        </div>
      `;
    }

    function escapeHtml(text) {
      if(!text) return "";
      return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }

    // Global Functions for inline onclick
    window.toggleReplyForm = function(id) {
      const el = document.getElementById(`reply-form-${id}`);
      if(el) {
        el.classList.toggle('active');
        if(el.classList.contains('active')) {
          const area = document.getElementById(`reply-input-${id}`);
          if(area) area.focus();
        }
      }
    };

    window.addComment = async function(parentId){
      let content = "";
      let area = null;
      
      if(parentId) {
        area = document.getElementById(`reply-input-${parentId}`);
      } else {
        area = inputEl;
      }
      content = area.value.trim();

      if(!content) { alert("ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”."); return; }

      try {
        const payload = { rel_path: REL_PATH, content: content };
        if(parentId) payload.parent_id = parentId;

        const res = await fetch('/research/comments/add', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify(payload)
        });
        
        if(res.ok) {
          area.value = '';
          if(parentId) toggleReplyForm(parentId); // close form
          loadComments(); 
        } else {
          alert("ì €ì¥ ì‹¤íŒ¨");
        }
      } catch(e) { alert("í†µì‹  ì˜¤ë¥˜ ë°œìƒ"); }
    };

    window.deleteComment = async function(id){
      if(!confirm("ì •ë§ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n(ë‹µê¸€ì´ ìˆëŠ” ê²½ìš° í•¨ê»˜ ì‚­ì œë©ë‹ˆë‹¤)")) return;
      try {
        const res = await fetch('/research/comments/delete', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({ id: id })
        });
        if(res.ok) loadComments();
      } catch(e) { alert("ì‚­ì œ ì‹¤íŒ¨"); }
    };

    window.editComment = async function(id){
      const bodyEl = document.getElementById(`cmt-body-${id}`);
      const currentText = bodyEl.innerText;
      
      // Simple prompt for editing (Can be improved to inline form)
      const newText = prompt("ëŒ“ê¸€ ìˆ˜ì •:", currentText);
      if(newText === null) return;
      if(!newText.trim()) return;
      if(newText === currentText) return;

      try {
        const res = await fetch('/research/comments/update', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({ id: id, content: newText })
        });
        if(res.ok) loadComments();
      } catch(e) { alert("ìˆ˜ì • ì‹¤íŒ¨"); }
    };

    // Initialize
    loadComments();
  })();

  // --- [B] Font Size Control ---
  (function(){
    const slider = document.getElementById('globalFontSize');
    const label = document.getElementById('globalFontVal');
    const container = document.getElementById('capture'); // Page container
    const body = document.getElementById('md-container'); // Markdown body

    if(slider && container && body) {
      const savedSize = localStorage.getItem('viewer_font_size');
      if(savedSize) { slider.value = savedSize; applySize(savedSize); }
      
      slider.addEventListener('input', (e) => applySize(e.target.value));
      
      function applySize(size) {
        label.innerText = size + 'px';
        // Apply to container to affect headers, comments etc.
        container.style.fontSize = size + 'px';
        // Apply explicit override to markdown body to ensure precedence
        body.style.fontSize = size + 'px';
        localStorage.setItem('viewer_font_size', size);
      }
    }
  })();

  // --- [C] PDF Generation (Robust) ---
  function openPdfSettings() { document.getElementById('pdfModal').style.display = 'flex'; }
  function closePdfSettings() { document.getElementById('pdfModal').style.display = 'none'; }
  function previewPdfFontSize(size) {
    document.getElementById('pdfFontSizeVal').innerText = size + 'px';
    const capture = document.getElementById('capture');
    if(capture) capture.style.fontSize = size + 'px';
  }

  async function convertSvgsToCanvas() {
    const containers = document.querySelectorAll('mjx-container');
    if (containers.length === 0) return;
    
    // Process in parallel
    const conversionPromises = Array.from(containers).map(async (container) => {
      const svg = container.querySelector('svg');
      if (!svg) return;

      const rect = svg.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;
      if (width <= 0 || height <= 0) return;

      const clone = svg.cloneNode(true);
      clone.setAttribute('width', width + 'px');
      clone.setAttribute('height', height + 'px');
      clone.setAttribute('xmlns', "http://www.w3.org/2000/svg");

      const computedStyle = window.getComputedStyle(svg);
      clone.style.fill = computedStyle.color || 'black';
      clone.style.stroke = computedStyle.color || 'black';
      clone.style.color = computedStyle.color || 'black';

      const serializer = new XMLSerializer();
      let svgString = serializer.serializeToString(clone);
      const encodedData = window.btoa(unescape(encodeURIComponent(svgString)));
      const imgSrc = 'data:image/svg+xml;base64,' + encodedData;

      // Create high-res canvas
      const scale = 3; 
      const canvas = document.createElement('canvas');
      canvas.width = width * scale;
      canvas.height = height * scale;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      canvas.style.display = 'inline-block';
      canvas.style.verticalAlign = 'middle';

      const ctx = canvas.getContext('2d');
      ctx.scale(scale, scale);

      await new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          ctx.drawImage(img, 0, 0, width, height);
          resolve();
        };
        img.onerror = () => { resolve(); }; // Skip on error
        img.src = imgSrc;
      });

      container.innerHTML = '';
      container.appendChild(canvas);
    });

    await Promise.all(conversionPromises);
  }

  async function startPdfGeneration() {
    // UI Update
    document.getElementById('pdfSettingsArea').style.display = 'none';
    document.getElementById('progressArea').style.display = 'block';
    document.getElementById('modalCloseBtn').style.display = 'none';
    const progressBar = document.getElementById('realProgressBar');
    
    let progress = 0;
    const interval = setInterval(() => {
      if (progress < 90) {
        progress += (90 - progress) / 20;
        progressBar.style.width = progress + '%';
      }
    }, 200);

    try {
      window.scrollTo(0, 0);
      document.getElementById('progressStatus').innerText = "ìˆ˜ì‹ì„ ì´ë¯¸ì§€ë¡œ ë³€í™˜ ì¤‘...";
      await convertSvgsToCanvas();

      document.getElementById('progressStatus').innerText = "PDF ìƒì„± ì¤‘...";
      
      const element = document.getElementById('capture');
      const orientation = document.getElementById('pdfOrientation').value;
      const marginType = document.getElementById('pdfMargin').value;
      
      let margins = [15, 15, 15, 15];
      if (marginType === 'narrow') margins = [5, 5, 5, 5];
      if (marginType === 'wide') margins = [25, 25, 25, 25];

      let filename = "{{ meta.paper_title or file_name }}";
      filename = filename.replace(/[^a-zA-Z0-9ê°€-í£\s]/g, "").trim();
      filename = (filename.substring(0, 50) || "document") + ".pdf";

      const opt = {
        margin:       margins,
        filename:     filename,
        image:        { type: 'jpeg', quality: 0.98 },
        html2canvas:  { scale: 2, useCORS: true, scrollY: 0, logging: false },
        jsPDF:        { unit: 'mm', format: 'a4', orientation: orientation },
        pagebreak:    { mode: ['avoid-all', 'css', 'legacy'] }
      };

      await html2pdf().set(opt).from(element).save();

      clearInterval(interval);
      progressBar.style.width = '100%';
      document.getElementById('progressStatus').innerText = "ì™„ë£Œ! (í˜ì´ì§€ë¥¼ ë³µêµ¬í•©ë‹ˆë‹¤)";

      setTimeout(() => { location.reload(); }, 2000);

    } catch (err) {
      console.error(err);
      clearInterval(interval);
      alert("PDF ìƒì„± ì˜¤ë¥˜: " + err.message);
      location.reload();
    }
  }

  // --- [D] Highlighting Logic (Robust) ---
  (function(){
    {% if html_content %}
      const container = document.getElementById("md-container");
      if (!container) return;

      const fab = document.getElementById("hl-fab");
      const toolbar = document.getElementById("hl-toolbar");
      const noteInput = document.getElementById("hl-note");
      const editBtn = document.getElementById("hl-edit");
      const saveBtn = document.getElementById("hl-save");
      const updateBtn = document.getElementById("hl-update");
      const deleteBtn = document.getElementById("hl-delete");
      const cancelBtn = document.getElementById("hl-cancel");
      const customColor = document.getElementById("hl-custom");

      // State
      const hlMap = new Map();
      const undoStack = [];
      let highlightEnabled = true;
      let currentColor = "#fff59d";
      let pendingRange = null;
      let editingId = null;
      let isPointerDown = false;

      // Mode Toggle
      function setMode(on){
        highlightEnabled = !!on;
        fab.dataset.on = highlightEnabled ? "1" : "0";
        fab.setAttribute("aria-pressed", highlightEnabled ? "true" : "false");
        if (!highlightEnabled) {
          hideToolbar();
          const sel = window.getSelection();
          if (sel) sel.removeAllRanges();
        }
        try { localStorage.setItem("highlight_enabled_v1", highlightEnabled ? "1" : "0"); } catch(e){}
      }
      (function initMode(){
        try{
          const v = localStorage.getItem("highlight_enabled_v1");
          if (v === "0") setMode(false); else setMode(true);
        }catch(e){ setMode(true); }
      })();
      fab.addEventListener("click", () => setMode(!highlightEnabled));

      // Color Picker
      toolbar.querySelectorAll(".hl-color").forEach(btn => {
        btn.addEventListener("click", () => { 
          currentColor = btn.dataset.color; 
          customColor.value = currentColor; 
        });
      });
      customColor.addEventListener("input", () => { currentColor = customColor.value; });
      customColor.value = currentColor;

      // Toolbar UI
      function showToolbar(x, y){
        const w = Math.min(340, Math.max(260, window.innerWidth * 0.92));
        const left = Math.max(12, Math.min(x, window.innerWidth - (w + 12)));
        const top  = Math.max(12, Math.min(y, window.innerHeight - 220));
        toolbar.style.left = left + "px";
        toolbar.style.top  = top + "px";
        toolbar.style.display = "block";
      }
      function hideToolbar(){
        toolbar.style.display = "none";
        pendingRange = null; editingId = null; noteInput.value = "";
        saveBtn.style.display = "inline-block";
        updateBtn.style.display = "none";
        deleteBtn.style.display = "none";
      }

      // Interaction
      container.addEventListener("pointerdown", () => { isPointerDown = true; }, { passive: true });
      document.addEventListener("pointerup", () => {
        isPointerDown = false; 
        setTimeout(tryOpenToolbarFromSelection, 0); 
      }, { passive: true });

      function tryOpenToolbarFromSelection(){
        if (!highlightEnabled || isPointerDown) return;
        
        // Ignore if clicking inputs
        if(document.activeElement && (document.activeElement.tagName==='INPUT' || document.activeElement.tagName==='TEXTAREA')) return;

        const sel = window.getSelection();
        if (!sel || sel.rangeCount === 0 || sel.isCollapsed) return;
        const range = sel.getRangeAt(0);
        if (!container.contains(range.commonAncestorContainer)) return;

        pendingRange = range.cloneRange();
        editingId = null;
        saveBtn.style.display = "inline-block";
        updateBtn.style.display = "none";
        deleteBtn.style.display = "none";
        noteInput.value = "";

        let rect = range.getBoundingClientRect();
        if (rect.width === 0) {
           // fallback logic needed if 0
        }
        showToolbar(rect.left + rect.width/2, rect.top - 10);
        // try { noteInput.focus({preventScroll:true}); } catch(e){}
        try { saveBtn.focus({preventScroll:true}); } catch(e){}
      }

      container.addEventListener("click", (e) => {
        const el = e.target.closest(".hl-span");
        if (!el || !highlightEnabled) return;
        
        editingId = el.dataset.hlId || null;
        pendingRange = null;
        noteInput.value = el.dataset.hlNote || "";
        currentColor = el.dataset.hlColor || currentColor;
        customColor.value = currentColor;

        saveBtn.style.display = "none";
        updateBtn.style.display = "inline-block";
        deleteBtn.style.display = "inline-block";
        
        showToolbar(e.clientX, e.clientY);
      });

      // Actions
      saveBtn.addEventListener("click", async () => {
        try{
          if (!highlightEnabled || !pendingRange) return;
          const {start, end, text} = getOffsetsFromRange(pendingRange);
          const memo = (noteInput.value || "").trim();
          const res = await apiAddHighlight({ 
            rel_path: REL_PATH, start, end, color: currentColor, text: (text||"").trim(), content_hash: NOTE_HASH, note: memo 
          });
          const hid = res.id;
          applyHighlightByOffsets(start, end, hid, currentColor, memo);
          hlMap.set(hid, { id: hid, start, end, color: currentColor, note: memo });
          undoStack.push({ op: "add", id: hid });
          window.getSelection().removeAllRanges();
          hideToolbar();
        }catch(e){ alert("ì €ì¥ ì‹¤íŒ¨: " + e); }
      });

      updateBtn.addEventListener("click", async () => {
        try{
          if (!highlightEnabled || !editingId) return;
          const memo = (noteInput.value || "").trim();
          const prev = hlMap.get(editingId) || {};
          await apiUpdateHighlight({ rel_path: REL_PATH, id: editingId, color: currentColor, note: memo });
          setAllSpansColor(editingId, currentColor);
          setAllSpansNote(editingId, memo);
          hlMap.set(editingId, { ...prev, color: currentColor, note: memo });
          undoStack.push({ op: "update", id: editingId, prev, next: { color: currentColor, note: memo } });
          hideToolbar();
        }catch(e){ alert("ìˆ˜ì • ì‹¤íŒ¨: " + e); }
      });

      deleteBtn.addEventListener("click", async () => {
        try{
          if (!highlightEnabled || !editingId) return;
          const prev = hlMap.get(editingId);
          await apiDeleteHighlight({ rel_path: REL_PATH, id: editingId });
          unwrapHighlight(editingId);
          hlMap.delete(editingId);
          undoStack.push({ op: "delete", prev });
          hideToolbar();
        }catch(e){ alert("ì‚­ì œ ì‹¤íŒ¨: " + e); }
      });

      cancelBtn.addEventListener("click", hideToolbar);
      document.addEventListener("pointerdown", (e) => {
        if(toolbar.style.display==="block" && !toolbar.contains(e.target) && !e.target.closest(".hl-span")) hideToolbar();
      });

      // --- Helper Functions (DOM) ---
      function getOffsetsFromRange(range){
        const pre1 = document.createRange(); pre1.selectNodeContents(container); pre1.setEnd(range.startContainer, range.startOffset);
        const start = pre1.toString().length;
        const pre2 = document.createRange(); pre2.selectNodeContents(container); pre2.setEnd(range.endContainer, range.endOffset);
        const end = pre2.toString().length;
        return { start, end, text: range.toString() };
      }

      function applyHighlightByOffsets(start, end, id, color, note){
        if (end <= start) return;
        const nodes = [];
        let pos = 0;
        const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, null);
        let n;
        while(n = walker.nextNode()){
          const len = (n.nodeValue || "").length;
          nodes.push({ node: n, start: pos, end: pos + len });
          pos += len;
        }

        let endMarked = false;
        const memo = (note || "").trim();

        for (let i = nodes.length - 1; i >= 0; i--){
          const info = nodes[i];
          if (info.end <= start) break;
          if (info.start >= end) continue;

          const a = Math.max(start, info.start) - info.start;
          const b = Math.min(end, info.end) - info.start;
          if (b <= a) continue;

          const full = info.node.nodeValue || "";
          const before = full.slice(0, a);
          const mid = full.slice(a, b);
          const after = full.slice(b);

          const frag = document.createDocumentFragment();
          if (before) frag.appendChild(document.createTextNode(before));
          const span = document.createElement("span");
          span.className = "hl-span";
          span.dataset.hlId = id;
          span.dataset.hlColor = color || "";
          span.dataset.hlNote = memo;
          span.style.backgroundColor = color;
          if (memo) span.title = memo;
          if (!endMarked){ span.dataset.hlEnd = "1"; endMarked = true; }
          span.textContent = mid;
          frag.appendChild(span);
          if (after) frag.appendChild(document.createTextNode(after));
          info.node.parentNode.replaceChild(frag, info.node);
        }
      }

      function setAllSpansColor(id, color){
        document.querySelectorAll(`[data-hl-id="${id}"]`).forEach(el => {
          el.style.backgroundColor = color; el.dataset.hlColor = color;
        });
      }
      function setAllSpansNote(id, note){
        const n = (note || "").trim();
        document.querySelectorAll(`[data-hl-id="${id}"]`).forEach(el => {
          el.dataset.hlNote = n; if(n) el.title = n; else el.removeAttribute("title");
        });
      }
      function unwrapHighlight(id){
        document.querySelectorAll(`[data-hl-id="${id}"]`).forEach(span => {
          span.replaceWith(document.createTextNode(span.textContent || ""));
        });
      }
      function getHighlightTextById(id){
        const spans = Array.from(document.querySelectorAll(`[data-hl-id="${id}"]`));
        return spans.map(x => x.textContent || "").join("").trim();
      }

      editBtn.addEventListener("click", () => {
        if(editingId){
           const s = getHighlightTextById(editingId);
           const st = hlMap.get(editingId);
           window.location.href = `${EDIT_URL}?rel_path=${encodeURIComponent(REL_PATH)}&focus=1&start=${st?.start||0}&snippet=${encodeURIComponent(s.slice(0,500))}`;
        } else if(pendingRange){
           const {start, text} = getOffsetsFromRange(pendingRange);
           window.location.href = `${EDIT_URL}?rel_path=${encodeURIComponent(REL_PATH)}&focus=1&start=${start}&snippet=${encodeURIComponent(text.slice(0,500))}`;
        }
      });

      // API Wrappers
      async function apiGetHighlights(){ const res = await fetch(`/research/highlights?rel_path=${encodeURIComponent(REL_PATH)}`); return await res.json(); }
      async function apiAddHighlight(pl){ const res = await fetch("/research/highlights/add", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(pl) }); if(!res.ok) throw new Error("Add failed"); return await res.json(); }
      async function apiUpdateHighlight(pl){ const res = await fetch("/research/highlights/update", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(pl) }); if(!res.ok) throw new Error("Update failed"); return await res.json(); }
      async function apiDeleteHighlight(pl){ const res = await fetch("/research/highlights/delete", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(pl) }); if(!res.ok) throw new Error("Delete failed"); return await res.json(); }

      // Undo
      async function undoLast(){
        if(!undoStack.length) return;
        const act = undoStack.pop();
        try{
          if(act.op === "add"){
             await apiDeleteHighlight({ rel_path: REL_PATH, id: act.id });
             unwrapHighlight(act.id); hlMap.delete(act.id);
          } else if(act.op === "update"){
             await apiUpdateHighlight({ rel_path: REL_PATH, id: act.id, color: act.prev.color, note: act.prev.note });
             setAllSpansColor(act.id, act.prev.color); setAllSpansNote(act.id, act.prev.note);
          } else if(act.op === "delete"){
             const prev = act.prev;
             const res = await apiAddHighlight({ rel_path: REL_PATH, start: prev.start, end: prev.end, color: prev.color, text: prev.text, content_hash: prev.content_hash, note: prev.note });
             applyHighlightByOffsets(prev.start, prev.end, res.id, prev.color, prev.note);
             hlMap.set(res.id, { ...prev, id: res.id });
          }
        }catch(e){ alert("Undo ì‹¤íŒ¨: " + e); }
      }
      document.addEventListener("keydown", (e) => {
        if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==="z" && !e.shiftKey && !isTypingTarget(document.activeElement)){
          e.preventDefault(); undoLast();
        }
      });

      // Initial Load
      (async function init(){
        try{
          const data = await apiGetHighlights();
          const items = (data.items || []).slice().sort((a,b) => (b.start||0) - (a.start||0));
          const fullText = container.textContent || "";
          for(const it of items){
            let s = parseInt(it.start, 10), e = parseInt(it.end, 10);
            // Stale adjustment
            if(it.stale && it.text){
              const idx = fullText.indexOf((it.text||"").trim(), Math.max(0, s - 800));
              if(idx >= 0){ s = idx; e = idx + (it.text||"").trim().length; } 
              else continue; 
            }
            applyHighlightByOffsets(s, e, it.id, it.color||"#fff59d", (it.note||"").trim());
            hlMap.set(it.id, { id: it.id, start: s, end: e, color: it.color, note: it.note, text: it.text });
          }
        }catch(e){ console.warn("HL Init Error", e); }
      })();

    {% endif %}
  })();

  // [Helper] í˜„ì¬ í¬ì»¤ìŠ¤ê°€ ì…ë ¥ì°½(ëŒ“ê¸€, ë©”ëª¨ ë“±)ì¸ì§€ í™•ì¸
      function isTypingTarget(el) {
        if (!el) return false;
        const tag = el.tagName.toUpperCase();
        return (tag === 'INPUT' || tag === 'TEXTAREA' || el.isContentEditable);
      }

      // [Event] Ctrl+Z (ë˜ëŠ” Cmd+Z) ëˆŒë €ì„ ë•Œ ì‹¤í–‰ ì·¨ì†Œ
      document.addEventListener("keydown", (e) => {
        // 1. Ctrl(ë˜ëŠ” Command) + Z ì¸ì§€ í™•ì¸ (Shiftê°€ ëˆŒë¦¬ì§€ ì•Šì€ ìƒíƒœ)
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "z" && !e.shiftKey) {
          
          // 2. ì‚¬ìš©ìê°€ ì…ë ¥ì°½ì— íƒ€ì´í•‘ ì¤‘ì´ ì•„ë‹ˆë¼ë©´ -> í•˜ì´ë¼ì´íŠ¸ ì·¨ì†Œ ì‹¤í–‰
          if (!isTypingTarget(document.activeElement)) {
            e.preventDefault(); // ë¸Œë¼ìš°ì €ì˜ ê¸°ë³¸ ì‹¤í–‰ ì·¨ì†Œ(í…ìŠ¤íŠ¸ ë˜ëŒë¦¬ê¸° ë“±) ë°©ì§€
            undoLast();         // ìŠ¤íƒì— ìˆëŠ” ë§ˆì§€ë§‰ í•˜ì´ë¼ì´íŠ¸ ì‚­ì œ í•¨ìˆ˜ í˜¸ì¶œ
          }
        }
      });
</script>

{% endblock %}